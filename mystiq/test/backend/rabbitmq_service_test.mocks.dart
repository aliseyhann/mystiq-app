// Mocks generated by Mockito 5.4.4 from annotations
// in mystiq_fortune_app/test/backend/rabbitmq_service_test.dart.
// Do not manually edit this file.

// ignore_for_file: no_leading_underscores_for_library_prefixes
import 'dart:async' as _i4;

import 'package:dart_amqp/src/client.dart' as _i2;
import 'package:dart_amqp/src/enums.dart' as _i5;
import 'package:dart_amqp/src/protocol.dart' as _i3;
import 'package:mockito/mockito.dart' as _i1;
import 'package:mockito/src/dummies.dart' as _i6;

// ignore_for_file: type=lint
// ignore_for_file: avoid_redundant_argument_values
// ignore_for_file: avoid_setters_without_getters
// ignore_for_file: comment_references
// ignore_for_file: deprecated_member_use
// ignore_for_file: deprecated_member_use_from_same_package
// ignore_for_file: implementation_imports
// ignore_for_file: invalid_use_of_visible_for_testing_member
// ignore_for_file: prefer_const_constructors
// ignore_for_file: unnecessary_parenthesis
// ignore_for_file: camel_case_types
// ignore_for_file: subtype_of_sealed_class

class _FakeConnectionSettings_0 extends _i1.SmartFake
    implements _i2.ConnectionSettings {
  _FakeConnectionSettings_0(
    Object parent,
    Invocation parentInvocation,
  ) : super(
          parent,
          parentInvocation,
        );
}

class _FakeTuningSettings_1 extends _i1.SmartFake
    implements _i3.TuningSettings {
  _FakeTuningSettings_1(
    Object parent,
    Invocation parentInvocation,
  ) : super(
          parent,
          parentInvocation,
        );
}

class _FakeChannel_2 extends _i1.SmartFake implements _i2.Channel {
  _FakeChannel_2(
    Object parent,
    Invocation parentInvocation,
  ) : super(
          parent,
          parentInvocation,
        );
}

class _FakeStreamSubscription_3<T> extends _i1.SmartFake
    implements _i4.StreamSubscription<T> {
  _FakeStreamSubscription_3(
    Object parent,
    Invocation parentInvocation,
  ) : super(
          parent,
          parentInvocation,
        );
}

class _FakeQueue_4 extends _i1.SmartFake implements _i2.Queue {
  _FakeQueue_4(
    Object parent,
    Invocation parentInvocation,
  ) : super(
          parent,
          parentInvocation,
        );
}

class _FakeExchange_5 extends _i1.SmartFake implements _i2.Exchange {
  _FakeExchange_5(
    Object parent,
    Invocation parentInvocation,
  ) : super(
          parent,
          parentInvocation,
        );
}

class _FakeConsumer_6 extends _i1.SmartFake implements _i2.Consumer {
  _FakeConsumer_6(
    Object parent,
    Invocation parentInvocation,
  ) : super(
          parent,
          parentInvocation,
        );
}

/// A class which mocks [Client].
///
/// See the documentation for Mockito's code generation for more information.
class MockClient extends _i1.Mock implements _i2.Client {
  MockClient() {
    _i1.throwOnMissingStub(this);
  }

  @override
  _i2.ConnectionSettings get settings => (super.noSuchMethod(
        Invocation.getter(#settings),
        returnValue: _FakeConnectionSettings_0(
          this,
          Invocation.getter(#settings),
        ),
      ) as _i2.ConnectionSettings);

  @override
  _i3.TuningSettings get tuningSettings => (super.noSuchMethod(
        Invocation.getter(#tuningSettings),
        returnValue: _FakeTuningSettings_1(
          this,
          Invocation.getter(#tuningSettings),
        ),
      ) as _i3.TuningSettings);

  @override
  bool get handshaking => (super.noSuchMethod(
        Invocation.getter(#handshaking),
        returnValue: false,
      ) as bool);

  @override
  _i4.Future<dynamic> connect() => (super.noSuchMethod(
        Invocation.method(
          #connect,
          [],
        ),
        returnValue: _i4.Future<dynamic>.value(),
      ) as _i4.Future<dynamic>);

  @override
  _i4.Future<dynamic> close() => (super.noSuchMethod(
        Invocation.method(
          #close,
          [],
        ),
        returnValue: _i4.Future<dynamic>.value(),
      ) as _i4.Future<dynamic>);

  @override
  _i4.Future<_i2.Channel> channel() => (super.noSuchMethod(
        Invocation.method(
          #channel,
          [],
        ),
        returnValue: _i4.Future<_i2.Channel>.value(_FakeChannel_2(
          this,
          Invocation.method(
            #channel,
            [],
          ),
        )),
      ) as _i4.Future<_i2.Channel>);

  @override
  _i4.StreamSubscription<Exception> errorListener(
    void Function(Exception)? onData, {
    Function? onError,
    void Function()? onDone,
    bool? cancelOnError,
  }) =>
      (super.noSuchMethod(
        Invocation.method(
          #errorListener,
          [onData],
          {
            #onError: onError,
            #onDone: onDone,
            #cancelOnError: cancelOnError,
          },
        ),
        returnValue: _FakeStreamSubscription_3<Exception>(
          this,
          Invocation.method(
            #errorListener,
            [onData],
            {
              #onError: onError,
              #onDone: onDone,
              #cancelOnError: cancelOnError,
            },
          ),
        ),
      ) as _i4.StreamSubscription<Exception>);
}

/// A class which mocks [Channel].
///
/// See the documentation for Mockito's code generation for more information.
class MockChannel extends _i1.Mock implements _i2.Channel {
  MockChannel() {
    _i1.throwOnMissingStub(this);
  }

  @override
  _i4.Future<_i2.Channel> close() => (super.noSuchMethod(
        Invocation.method(
          #close,
          [],
        ),
        returnValue: _i4.Future<_i2.Channel>.value(_FakeChannel_2(
          this,
          Invocation.method(
            #close,
            [],
          ),
        )),
      ) as _i4.Future<_i2.Channel>);

  @override
  _i4.Future<_i2.Queue> queue(
    String? name, {
    bool? passive = false,
    bool? durable = false,
    bool? exclusive = false,
    bool? autoDelete = false,
    bool? noWait = false,
    bool? declare = true,
    Map<String, Object>? arguments,
  }) =>
      (super.noSuchMethod(
        Invocation.method(
          #queue,
          [name],
          {
            #passive: passive,
            #durable: durable,
            #exclusive: exclusive,
            #autoDelete: autoDelete,
            #noWait: noWait,
            #declare: declare,
            #arguments: arguments,
          },
        ),
        returnValue: _i4.Future<_i2.Queue>.value(_FakeQueue_4(
          this,
          Invocation.method(
            #queue,
            [name],
            {
              #passive: passive,
              #durable: durable,
              #exclusive: exclusive,
              #autoDelete: autoDelete,
              #noWait: noWait,
              #declare: declare,
              #arguments: arguments,
            },
          ),
        )),
      ) as _i4.Future<_i2.Queue>);

  @override
  _i4.Future<_i2.Queue> privateQueue({
    bool? noWait = false,
    Map<String, Object>? arguments,
  }) =>
      (super.noSuchMethod(
        Invocation.method(
          #privateQueue,
          [],
          {
            #noWait: noWait,
            #arguments: arguments,
          },
        ),
        returnValue: _i4.Future<_i2.Queue>.value(_FakeQueue_4(
          this,
          Invocation.method(
            #privateQueue,
            [],
            {
              #noWait: noWait,
              #arguments: arguments,
            },
          ),
        )),
      ) as _i4.Future<_i2.Queue>);

  @override
  _i4.Future<_i2.Exchange> exchange(
    String? name,
    _i5.ExchangeType? type, {
    bool? passive = false,
    bool? durable = false,
    bool? noWait = false,
    Map<String, Object>? arguments,
  }) =>
      (super.noSuchMethod(
        Invocation.method(
          #exchange,
          [
            name,
            type,
          ],
          {
            #passive: passive,
            #durable: durable,
            #noWait: noWait,
            #arguments: arguments,
          },
        ),
        returnValue: _i4.Future<_i2.Exchange>.value(_FakeExchange_5(
          this,
          Invocation.method(
            #exchange,
            [
              name,
              type,
            ],
            {
              #passive: passive,
              #durable: durable,
              #noWait: noWait,
              #arguments: arguments,
            },
          ),
        )),
      ) as _i4.Future<_i2.Exchange>);

  @override
  _i4.Future<_i2.Channel> qos(
    int? prefetchSize,
    int? prefetchCount, {
    bool? global = true,
  }) =>
      (super.noSuchMethod(
        Invocation.method(
          #qos,
          [
            prefetchSize,
            prefetchCount,
          ],
          {#global: global},
        ),
        returnValue: _i4.Future<_i2.Channel>.value(_FakeChannel_2(
          this,
          Invocation.method(
            #qos,
            [
              prefetchSize,
              prefetchCount,
            ],
            {#global: global},
          ),
        )),
      ) as _i4.Future<_i2.Channel>);

  @override
  void ack(
    int? deliveryTag, {
    bool? multiple = false,
  }) =>
      super.noSuchMethod(
        Invocation.method(
          #ack,
          [deliveryTag],
          {#multiple: multiple},
        ),
        returnValueForMissingStub: null,
      );

  @override
  _i4.Future<_i2.Channel> select() => (super.noSuchMethod(
        Invocation.method(
          #select,
          [],
        ),
        returnValue: _i4.Future<_i2.Channel>.value(_FakeChannel_2(
          this,
          Invocation.method(
            #select,
            [],
          ),
        )),
      ) as _i4.Future<_i2.Channel>);

  @override
  _i4.Future<_i2.Channel> commit() => (super.noSuchMethod(
        Invocation.method(
          #commit,
          [],
        ),
        returnValue: _i4.Future<_i2.Channel>.value(_FakeChannel_2(
          this,
          Invocation.method(
            #commit,
            [],
          ),
        )),
      ) as _i4.Future<_i2.Channel>);

  @override
  _i4.Future<_i2.Channel> rollback() => (super.noSuchMethod(
        Invocation.method(
          #rollback,
          [],
        ),
        returnValue: _i4.Future<_i2.Channel>.value(_FakeChannel_2(
          this,
          Invocation.method(
            #rollback,
            [],
          ),
        )),
      ) as _i4.Future<_i2.Channel>);

  @override
  _i4.Future<_i2.Channel> flow(bool? active) => (super.noSuchMethod(
        Invocation.method(
          #flow,
          [active],
        ),
        returnValue: _i4.Future<_i2.Channel>.value(_FakeChannel_2(
          this,
          Invocation.method(
            #flow,
            [active],
          ),
        )),
      ) as _i4.Future<_i2.Channel>);

  @override
  _i4.Future<_i2.Channel> recover(bool? requeue) => (super.noSuchMethod(
        Invocation.method(
          #recover,
          [requeue],
        ),
        returnValue: _i4.Future<_i2.Channel>.value(_FakeChannel_2(
          this,
          Invocation.method(
            #recover,
            [requeue],
          ),
        )),
      ) as _i4.Future<_i2.Channel>);

  @override
  _i4.StreamSubscription<_i2.BasicReturnMessage> basicReturnListener(
    void Function(_i2.BasicReturnMessage)? onData, {
    Function? onError,
    void Function()? onDone,
    bool? cancelOnError,
  }) =>
      (super.noSuchMethod(
        Invocation.method(
          #basicReturnListener,
          [onData],
          {
            #onError: onError,
            #onDone: onDone,
            #cancelOnError: cancelOnError,
          },
        ),
        returnValue: _FakeStreamSubscription_3<_i2.BasicReturnMessage>(
          this,
          Invocation.method(
            #basicReturnListener,
            [onData],
            {
              #onError: onError,
              #onDone: onDone,
              #cancelOnError: cancelOnError,
            },
          ),
        ),
      ) as _i4.StreamSubscription<_i2.BasicReturnMessage>);

  @override
  _i4.StreamSubscription<_i2.PublishNotification> publishNotifier(
    void Function(_i2.PublishNotification)? onData, {
    Function? onError,
    void Function()? onDone,
    bool? cancelOnError,
  }) =>
      (super.noSuchMethod(
        Invocation.method(
          #publishNotifier,
          [onData],
          {
            #onError: onError,
            #onDone: onDone,
            #cancelOnError: cancelOnError,
          },
        ),
        returnValue: _FakeStreamSubscription_3<_i2.PublishNotification>(
          this,
          Invocation.method(
            #publishNotifier,
            [onData],
            {
              #onError: onError,
              #onDone: onDone,
              #cancelOnError: cancelOnError,
            },
          ),
        ),
      ) as _i4.StreamSubscription<_i2.PublishNotification>);

  @override
  _i4.Future<dynamic> confirmPublishedMessages() => (super.noSuchMethod(
        Invocation.method(
          #confirmPublishedMessages,
          [],
        ),
        returnValue: _i4.Future<dynamic>.value(),
      ) as _i4.Future<dynamic>);
}

/// A class which mocks [Consumer].
///
/// See the documentation for Mockito's code generation for more information.
class MockConsumer extends _i1.Mock implements _i2.Consumer {
  MockConsumer() {
    _i1.throwOnMissingStub(this);
  }

  @override
  String get tag => (super.noSuchMethod(
        Invocation.getter(#tag),
        returnValue: _i6.dummyValue<String>(
          this,
          Invocation.getter(#tag),
        ),
      ) as String);

  @override
  _i2.Channel get channel => (super.noSuchMethod(
        Invocation.getter(#channel),
        returnValue: _FakeChannel_2(
          this,
          Invocation.getter(#channel),
        ),
      ) as _i2.Channel);

  @override
  _i2.Queue get queue => (super.noSuchMethod(
        Invocation.getter(#queue),
        returnValue: _FakeQueue_4(
          this,
          Invocation.getter(#queue),
        ),
      ) as _i2.Queue);

  @override
  _i4.StreamSubscription<_i2.AmqpMessage> listen(
    void Function(_i2.AmqpMessage)? onData, {
    Function? onError,
    void Function()? onDone,
    bool? cancelOnError,
  }) =>
      (super.noSuchMethod(
        Invocation.method(
          #listen,
          [onData],
          {
            #onError: onError,
            #onDone: onDone,
            #cancelOnError: cancelOnError,
          },
        ),
        returnValue: _FakeStreamSubscription_3<_i2.AmqpMessage>(
          this,
          Invocation.method(
            #listen,
            [onData],
            {
              #onError: onError,
              #onDone: onDone,
              #cancelOnError: cancelOnError,
            },
          ),
        ),
      ) as _i4.StreamSubscription<_i2.AmqpMessage>);

  @override
  _i4.Future<_i2.Consumer> cancel({bool? noWait = false}) =>
      (super.noSuchMethod(
        Invocation.method(
          #cancel,
          [],
          {#noWait: noWait},
        ),
        returnValue: _i4.Future<_i2.Consumer>.value(_FakeConsumer_6(
          this,
          Invocation.method(
            #cancel,
            [],
            {#noWait: noWait},
          ),
        )),
      ) as _i4.Future<_i2.Consumer>);
}

/// A class which mocks [Queue].
///
/// See the documentation for Mockito's code generation for more information.
class MockQueue extends _i1.Mock implements _i2.Queue {
  MockQueue() {
    _i1.throwOnMissingStub(this);
  }

  @override
  String get name => (super.noSuchMethod(
        Invocation.getter(#name),
        returnValue: _i6.dummyValue<String>(
          this,
          Invocation.getter(#name),
        ),
      ) as String);

  @override
  int get messageCount => (super.noSuchMethod(
        Invocation.getter(#messageCount),
        returnValue: 0,
      ) as int);

  @override
  int get consumerCount => (super.noSuchMethod(
        Invocation.getter(#consumerCount),
        returnValue: 0,
      ) as int);

  @override
  _i2.Channel get channel => (super.noSuchMethod(
        Invocation.getter(#channel),
        returnValue: _FakeChannel_2(
          this,
          Invocation.getter(#channel),
        ),
      ) as _i2.Channel);

  @override
  _i4.Future<_i2.Queue> delete({
    bool? ifUnused = false,
    bool? ifEmpty = false,
    bool? noWait = false,
  }) =>
      (super.noSuchMethod(
        Invocation.method(
          #delete,
          [],
          {
            #ifUnused: ifUnused,
            #ifEmpty: ifEmpty,
            #noWait: noWait,
          },
        ),
        returnValue: _i4.Future<_i2.Queue>.value(_FakeQueue_4(
          this,
          Invocation.method(
            #delete,
            [],
            {
              #ifUnused: ifUnused,
              #ifEmpty: ifEmpty,
              #noWait: noWait,
            },
          ),
        )),
      ) as _i4.Future<_i2.Queue>);

  @override
  _i4.Future<_i2.Queue> purge({bool? noWait = false}) => (super.noSuchMethod(
        Invocation.method(
          #purge,
          [],
          {#noWait: noWait},
        ),
        returnValue: _i4.Future<_i2.Queue>.value(_FakeQueue_4(
          this,
          Invocation.method(
            #purge,
            [],
            {#noWait: noWait},
          ),
        )),
      ) as _i4.Future<_i2.Queue>);

  @override
  _i4.Future<_i2.Queue> bind(
    _i2.Exchange? exchange,
    String? routingKey, {
    bool? noWait,
    Map<String, Object>? arguments,
  }) =>
      (super.noSuchMethod(
        Invocation.method(
          #bind,
          [
            exchange,
            routingKey,
          ],
          {
            #noWait: noWait,
            #arguments: arguments,
          },
        ),
        returnValue: _i4.Future<_i2.Queue>.value(_FakeQueue_4(
          this,
          Invocation.method(
            #bind,
            [
              exchange,
              routingKey,
            ],
            {
              #noWait: noWait,
              #arguments: arguments,
            },
          ),
        )),
      ) as _i4.Future<_i2.Queue>);

  @override
  _i4.Future<_i2.Queue> unbind(
    _i2.Exchange? exchange,
    String? routingKey, {
    bool? noWait,
    Map<String, Object>? arguments,
  }) =>
      (super.noSuchMethod(
        Invocation.method(
          #unbind,
          [
            exchange,
            routingKey,
          ],
          {
            #noWait: noWait,
            #arguments: arguments,
          },
        ),
        returnValue: _i4.Future<_i2.Queue>.value(_FakeQueue_4(
          this,
          Invocation.method(
            #unbind,
            [
              exchange,
              routingKey,
            ],
            {
              #noWait: noWait,
              #arguments: arguments,
            },
          ),
        )),
      ) as _i4.Future<_i2.Queue>);

  @override
  void publish(
    Object? message, {
    _i3.MessageProperties? properties,
    bool? mandatory = false,
    bool? immediate = false,
  }) =>
      super.noSuchMethod(
        Invocation.method(
          #publish,
          [message],
          {
            #properties: properties,
            #mandatory: mandatory,
            #immediate: immediate,
          },
        ),
        returnValueForMissingStub: null,
      );

  @override
  _i4.Future<_i2.Consumer> consume({
    String? consumerTag,
    bool? noLocal = false,
    bool? noAck = true,
    bool? exclusive = false,
    bool? noWait = false,
    Map<String, Object>? arguments,
  }) =>
      (super.noSuchMethod(
        Invocation.method(
          #consume,
          [],
          {
            #consumerTag: consumerTag,
            #noLocal: noLocal,
            #noAck: noAck,
            #exclusive: exclusive,
            #noWait: noWait,
            #arguments: arguments,
          },
        ),
        returnValue: _i4.Future<_i2.Consumer>.value(_FakeConsumer_6(
          this,
          Invocation.method(
            #consume,
            [],
            {
              #consumerTag: consumerTag,
              #noLocal: noLocal,
              #noAck: noAck,
              #exclusive: exclusive,
              #noWait: noWait,
              #arguments: arguments,
            },
          ),
        )),
      ) as _i4.Future<_i2.Consumer>);
}
